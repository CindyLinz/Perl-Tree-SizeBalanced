// vim: filetype=xs
#ifndef TREE__H
#define TREE__H

#include "EXTERN.h"
#include "perl.h"

#define SEG_SIZE (512)
#define TREE_iv_SECRET (5673533590968723872LL)
#define TREE_nv_SECRET (5673533590968723873LL)
#define TREE_sv_SECRET (5673533590968723874LL)

typedef union {
    IV key_iv;
    NV key_nv;
    SV* key_sv;
} tree_key_t;

static inline tree_key_t tree_key_iv(IV value){
    tree_key_t key = {.key_iv = value};
    return key;
}
static inline tree_key_t tree_key_nv(NV value){
    tree_key_t key = {.key_nv = value};
    return key;
}
static inline tree_key_t tree_key_pv(SV* value){
    tree_key_t key = {.key_sv = value};
    return key;
}
static inline tree_key_t tree_key_sv(SV* value){
    tree_key_t key = {.key_sv = value};
    return key;
}

static inline tree_key_t max_key_iv(){
    return tree_key_iv((((1 << (IVSIZE - 2)) - 1) << 1) + 1);
}
static inline tree_key_t min_key_iv(){
    return tree_key_iv(-(((1 << (IVSIZE - 2)) - 1) << 1) - 2);
}
static inline tree_key_t max_key_nv(){
    return tree_key_nv(INFINITY);
}
static inline tree_key_t min_key_nv(){
    return tree_key_nv(-INFINITY);
}
static inline tree_key_t max_key_sv(){
    return tree_key_sv(&PL_sv_undef);
}
static inline tree_key_t min_key_sv(){
    return tree_key_sv(&PL_sv_undef);
}

static inline bool ident_iv(tree_key_t key1, tree_key_t key2){
    return key1.key_iv == key2.key_iv;
}
static inline bool ident_nv(tree_key_t key1, tree_key_t key2){
    return key1.key_nv == key2.key_nv;
}
static inline bool ident_sv(tree_key_t key1, tree_key_t key2){
    return key1.key_sv == key2.key_sv;
}

static inline SV** ret_key_iv(SV ** SP, tree_key_t key){
    dTARGET;
    PUSHi(key.key_iv);
    return SP;
}
static inline SV** ret_key_nv(SV ** SP, tree_key_t key){
    dTARGET;
    PUSHn(key.key_nv);
    return SP;
}
static inline SV** ret_key_sv(SV ** SP, tree_key_t key){
    PUSHs(key.key_sv);
    return SP;
}

typedef union tree_t {
    struct {
        tree_key_t key;
        union tree_t *left, *right;
        IV size;
    };
    union tree_t * free_slot;
} tree_t;

typedef struct tree_seg_t {
    struct tree_seg_t * prev_seg;

    tree_t cell[SEG_SIZE];
} tree_seg_t;

extern tree_t nil;

typedef IV (*cmp_t)(SV * a, SV * b);

static inline IV cmp_iv(tree_key_t a, tree_key_t b, cmp_t cmp){
    return a.key_iv - b.key_iv;
}

static inline NV cmp_nv(tree_key_t a, tree_key_t b, cmp_t cmp){
    return a.key_nv - b.key_nv;
}

static inline IV cmp_sv(tree_key_t a, tree_key_t b, cmp_t cmp){
    return cmp(a.key_sv, b.key_sv);
}

typedef struct tree_cntr_t {
    long long secret;
    cmp_t cmp;
    tree_t * root; // (init 後, empty 前) 永不為空, 一開始指向 nil
    tree_t * free_slot;
    tree_seg_t * newest_seg;
} tree_cntr_t;

// 把所有的 cell 以 free_slot 串起來, 最後一個指向 NULL
// return 開頭的 cell
static inline tree_t * init_tree_seg(tree_seg_t * seg, tree_seg_t * prev){
    seg->prev_seg = prev;
    seg->cell[SEG_SIZE-1].free_slot = NULL;
    for(int i=SEG_SIZE-2; i>=0; --i)
        seg->cell[i].free_slot = &seg->cell[i+1];
    return &seg->cell[0];
}

static inline void empty_tree_cntr(tree_cntr_t * cntr){
    tree_seg_t * seg = cntr->newest_seg;
    while( seg ){
        tree_seg_t * prev = seg->prev_seg;
        Safefree(seg);
        seg = prev;
    }
    cntr->root = &nil;
    cntr->free_slot = NULL;
    cntr->newest_seg = NULL;
}

static inline tree_t * allocate_cell(tree_cntr_t * cntr, tree_key_t key){
    if( UNLIKELY(!cntr->free_slot) ){
        tree_seg_t * new_seg;
        Newx(new_seg, 1, tree_seg_t);
        cntr->free_slot = init_tree_seg(new_seg, cntr->newest_seg);
        cntr->newest_seg = new_seg;
    }
    tree_t * new_cell = cntr->free_slot;
    cntr->free_slot = new_cell->free_slot;

    new_cell->left = new_cell->right = &nil;
    new_cell->size = 1;
    new_cell->key = key;

    return new_cell;
}

static inline void free_cell(tree_cntr_t * cntr, tree_t * cell){
    cell->free_slot = cntr->free_slot;
    cntr->free_slot = cell;
}

// 假設 t->right 存在, return 新的 subtree root
static inline tree_t* rotate_left(tree_t* t){
    tree_t * c = t->right;
    t->right = c->left;
    c->left = t;
    c->size = t->size;
    t->size = t->left->size + t->right->size + 1;
    return c;
}

// 假設 t->left 存在, return 新的 subtree root
static inline tree_t* rotate_right(tree_t * t){
    tree_t * c = t->left;
    t->left = c->right;
    c->right = t;
    c->size = t->size;
    t->size = t->left->size + t->right->size + 1;
    return c;
}

tree_t * maintain_larger_left(tree_t * t);
tree_t * maintain_larger_right(tree_t * t);

// 假設一給定的 tree 不是空的
// 把子樹的最右節點拉上來成為子樹的 root, return 新的 root
// 新子樹沒有右子樹, 而左子樹符合 SBTree 特性
static inline tree_t * tree_raise_max_cell(tree_t * tree){
    tree_t * root = tree;

    int step_count = 0;

    tree_t * parent = &nil;
    while( UNLIKELY(tree->right != &nil) ){
        --tree->size;
        parent = tree;
        tree = tree->right;
        ++step_count;
    }

    if( LIKELY(parent != &nil) ){
        parent->right = tree->left;
        tree->left = root;
        tree->size = root->size + 1;

        tree_t * stack[step_count];
        for(int i=0; i<step_count; ++i){
            stack[i] = root;
            root = root->right;
        }
        for(int i=step_count-1; i>0; --i)
            stack[i-1]->right = maintain_larger_left(stack[i]);
        tree->left = maintain_larger_left(stack[0]);
    }

    return tree;
}

// 假設 parent 的 right 是 nil
// 把 right 接到 parent 的 right
// re-return parent;
static inline tree_t * tree_assign_right(tree_t * parent, tree_t * right){
    parent->right = right;
    parent->size += right->size;
    return parent;
}

// 假設 tree 不是空的
// 如果有左子樹, 把此 tree 的 root 用左子樹裡最大節點取代
// 否則用右字樹取代
// return 新的 root
static inline tree_t * tree_replace_cell(tree_t * tree){
    if( UNLIKELY(tree->left == &nil) )
        return tree->right;
    return tree_assign_right(tree_raise_max_cell(tree->left), tree->right);
}

// 假設 tree 不是空的
// 刪除 tree 的 root
// return 新的 root
static inline tree_t * tree_delete_root(tree_cntr_t * cntr, tree_t * tree){
    tree_t * new_root = tree_replace_cell(tree);
    free_cell(cntr, tree);
    return new_root;
}

static inline int tree_size(tree_cntr_t * cntr){
    return cntr->root->size;
}

// 假設 tree 不是空的
static inline tree_key_t tree_find_min(tree_cntr_t * cntr){
    tree_t * t = cntr->root;
    while( t->left != &nil )
        t = t->left;
    return t->key;
}

// 假設 tree 不是空的
static inline tree_key_t tree_find_max(tree_cntr_t * cntr){
    tree_t * t = cntr->root;
    while( t->right != &nil )
        t = t->right;
    return t->key;
}

// 假設 0 <= offset < root->size
static inline tree_key_t tree_skip_l(tree_cntr_t * cntr, int offset){
    tree_t * t = cntr->root;
    while(TRUE){
        if( offset == t->left->size )
            return t->key;
        if( offset < t->left->size )
            t = t->left;
        else{
            offset -= t->left->size + 1;
            t = t->right;
        }
    }
}

// 假設 0 <= offset < root->size
static inline tree_key_t tree_skip_g(tree_cntr_t * cntr, int offset){
    tree_t * t = cntr->root;
    while(TRUE){
        if( offset == t->right->size )
            return t->key;
        if( offset < t->right->size )
            t = t->right;
        else{
            offset -= t->right->size + 1;
            t = t->left;
        }
    }
}

static inline void tree_dump_node_iv(tree_t * tree){
    PerlIO_printf(PerlIO_stdout(), "(%d, %d)\n", tree->key.key_iv, tree->size);
}
static inline void tree_dump_node_nv(tree_t * tree){
    PerlIO_printf(PerlIO_stdout(), "(%lf, %d)\n", tree->key.key_nv, tree->size);
}
static inline void tree_dump_node_sv(tree_t * tree){
    char * key = SvPV_nolen(tree->key.key_sv);
    PerlIO_printf(PerlIO_stdout(), "(%s, %d)\n", key, tree->size);
}

#define GEN_H_BY_TYPE(TYPE) {{{

static inline void init_tree_cntr_ ## TYPE(tree_cntr_t * cntr){
    cntr->secret = TREE_ ## TYPE ## _SECRET;
    cntr->root = &nil;
    cntr->newest_seg = NULL;
    cntr->free_slot = NULL;
}

tree_t * tree_insert_subtree_ ## TYPE(tree_cntr_t * cntr, tree_t * t, tree_key_t key, tree_t * new_tree);
static inline void tree_insert_ ## TYPE(tree_cntr_t * cntr, tree_key_t key){
    tree_t * new_tree = allocate_cell(cntr, key);

    if( UNLIKELY(cntr->root == &nil) ){
        cntr->root = new_tree;
        return;
    }

    cntr->root = tree_insert_subtree_ ## TYPE(cntr, cntr->root, key, new_tree);
}

tree_t * tree_delete_subtree_ ## TYPE(tree_cntr_t * cntr, tree_t * tree, tree_key_t key);

static inline bool tree_delete_ ## TYPE(tree_cntr_t * cntr, tree_key_t key){
    if( UNLIKELY(cntr->root == &nil) )
        return FALSE;

    if( cmp_ ## TYPE(cntr->root->key, key, cntr->cmp)==0 ){
        cntr->root = maintain_larger_right(tree_delete_root(cntr, cntr->root));
        return TRUE;
    }

    tree_t * new_root = tree_delete_subtree_ ## TYPE(cntr, cntr->root, key);
    if( new_root ){
        cntr->root = new_root;
        return TRUE;
    }
    return FALSE;
}

static inline bool tree_find_ ## TYPE(tree_cntr_t * cntr, tree_key_t key){
    tree_t * t = cntr->root;
    while( t != &nil ){
        if( cmp_ ## TYPE(t->key, key, cntr->cmp) == 0 )
            return TRUE;
        if( cmp_ ## TYPE(key, t->key, cntr->cmp) >= 0 )
            t = t->right;
        else
            t = t->left;
    }
    return FALSE;
}

static inline tree_key_t tree_find_lt_ ## TYPE(tree_cntr_t * cntr, tree_key_t not_found_key, tree_key_t key){
    tree_t * t = cntr->root;
    tree_key_t best = not_found_key;
    while( t != &nil ){
        if( cmp_ ## TYPE(t->key, key, cntr->cmp) < 0 ){
            best = t->key;
            t = t->right;
        }
        else
            t = t->left;
    }
    return best;
}

static inline tree_key_t tree_find_le_ ## TYPE(tree_cntr_t * cntr, tree_key_t not_found_key, tree_key_t key){
    tree_t * t = cntr->root;
    tree_key_t best = not_found_key;
    while( t != &nil ){
        if( cmp_ ## TYPE(t->key, key, cntr->cmp) <= 0 ){
            best = t->key;
            t = t->right;
        }
        else
            t = t->left;
    }
    return best;
}

static inline tree_key_t tree_find_gt_ ## TYPE(tree_cntr_t * cntr, tree_key_t not_found_key, tree_key_t key){
    tree_t * t = cntr->root;
    tree_key_t best = not_found_key;
    while( t != &nil ){
        if( cmp_ ## TYPE(t->key, key, cntr->cmp) > 0 ){
            best = t->key;
            t = t->left;
        }
        else
            t = t->right;
    }
    return best;
}

static inline tree_key_t tree_find_ge_ ## TYPE(tree_cntr_t * cntr, tree_key_t not_found_key, tree_key_t key){
    tree_t * t = cntr->root;
    tree_key_t best = not_found_key;
    while( t != &nil ){
        if( cmp_ ## TYPE(t->key, key, cntr->cmp) >= 0 ){
            best = t->key;
            t = t->left;
        }
        else
            t = t->right;
    }
    return best;
}

static inline int tree_count_lt_ ## TYPE(tree_cntr_t * cntr, tree_key_t key){
    tree_t * t = cntr->root;
    int count = 0;
    while( t != &nil ){
        if( cmp_ ## TYPE(key, t->key, cntr->cmp) > 0 ){
            count += t->left->size + 1;
            t = t->right;
        }
        else
            t = t->left;
    }
    return count;
}

static inline int tree_count_le_ ## TYPE(tree_cntr_t * cntr, tree_key_t key){
    tree_t * t = cntr->root;
    int count = 0;
    while( t != &nil ){
        if( cmp_ ## TYPE(key, t->key, cntr->cmp) >= 0 ){
            count += t->left->size + 1;
            t = t->right;
        }
        else
            t = t->left;
    }
    return count;
}

static inline int tree_count_gt_ ## TYPE(tree_cntr_t * cntr, tree_key_t key){
    tree_t * t = cntr->root;
    int count = 0;
    while( t != &nil ){
        if( cmp_ ## TYPE(key, t->key, cntr->cmp) < 0 ){
            count += t->right->size + 1;
            t = t->left;
        }
        else
            t = t->right;
    }
    return count;
}

static inline int tree_count_ge_ ## TYPE(tree_cntr_t * cntr, tree_key_t key){
    tree_t * t = cntr->root;
    int count = 0;
    while( t != &nil ){
        if( cmp_ ## TYPE(key, t->key, cntr->cmp) <= 0 ){
            count += t->right->size + 1;
            t = t->left;
        }
        else
            t = t->right;
    }
    return count;
}

void tree_dump_subtree_ ## TYPE(int indent, tree_t * tree);
static inline void tree_dump_ ## TYPE(tree_cntr_t * cntr){
    if( cntr->root == &nil ){
        puts("(empty tree)");
        return;
    }
    tree_dump_subtree_ ## TYPE(0, cntr->root);
}

bool tree_check_subtree_order_ ## TYPE(tree_cntr_t * cntr, tree_t * tree);
static inline bool tree_check_order_ ## TYPE(tree_cntr_t * cntr){
    if( cntr->root == &nil )
        return TRUE;
    return tree_check_subtree_order_ ## TYPE(cntr, cntr->root);
}

}}}

bool tree_check_subtree_size(tree_t * tree);
static inline bool tree_check_size(tree_cntr_t * cntr){
    if( cntr->root == &nil )
        return TRUE;
    return tree_check_subtree_size(cntr->root);
}

bool tree_check_subtree_balance(tree_t * tree);
static inline bool tree_check_balance(tree_cntr_t * cntr){
    if( cntr->root == &nil )
        return TRUE;
    return tree_check_subtree_balance(cntr->root);
}

GEN_H_BY_TYPE(iv)
GEN_H_BY_TYPE(nv)
GEN_H_BY_TYPE(sv)

#endif
